# CPU_simulation
This assignment simulate 3 cpu scheduling algorithms: FCFS(First Come First Serve), SJF(Shortest Job First), MFQ(Multi-Level Feedback Queue) in Python. 

In this assignment, we implemented a simulation of known CPU schedulers by eight processes containing both CPU burst, and I/O (Input/Output) burst times. Processes are any running programs on a computer and for these processes to execute, they must enter a ready queue to get to the CPU. With most computers handling dozens of processes at a time, there needs to be a way for the processes to enter and leave the CPU in an order that allows for other processes to execute. CPU schedulers such as First Come First Serve, allow for the first process that arrives first to execute completely before taking the next process. This means that the processes in this queue would have equal priority and be considered with the same importance as the scheduler. However, the First Come First Serve scheduler is very time-consuming and has a high overhead for the Operating System. A more optimal and efficient scheduler would be using Shortest Job First, which takes the process with the shortest burst time and allows it to execute first. However, there are two downsides to the Shortest Job First scheduler, the first being that SJF depends on the Operating System knowing the burst times of each process which it will never know prior to execution. The second flaw when using SJF would be that processing the shortest processes first could cause starvation to the CPU. This is due to processes with short burst times always being the priority. If shorter processes come along while there is a long queue of processes, the shorter processes will always supersede processes with longer burst times which would prevent those processes from ever executing. Aging would be the solution to this problem which would be increasing the priority of the processes after a certain amount of time. The last scheduler included in the programming assignment is the Multilevel Feedback Queue, which takes the processes and gives the processes different priority in levels on the queue. This queuing technique allows for all the processes in the ready queue to execute and saves time for the Operating System by executing the highest priorities first. 
           When developing the code for this assignment, I started with a simple pseudocode that would take the CPU burst from each process and push the value into a queue. This was difficult to conceptualize for SJF as the program would need to input the process, apply conditional statements, and push both the burst and I/O burst into a queue while keeping track of the arrival time, burst time, and completion of that process. This program is unique as many programming classes do not stray from the standard idea of creating queues and stacks. Rarely, is it demanded that we manipulate queuing in such a way. However, using Queues allows us to store those additional calculations such as the wait and turnaround time, and use those stored values to find averages along with data for our results tables. For each function in my code, I found it easier though perhaps not optimal to create separate functions to calculate the results for each scheduler, this way I did not lose the data in my queues every time I wanted to get or put information into the queue. For me, creating several different functions made it easier to fix any mistakes in the calculations. 


![image](https://github.com/user-attachments/assets/6adf5ff6-87ee-4524-ac73-6593c600cc38)

![image](https://github.com/user-attachments/assets/05ff8425-e385-44a6-ac61-d6ddc3551b73)

![image](https://github.com/user-attachments/assets/88296667-aef5-46d9-9161-45fac59e6494)

![image](https://github.com/user-attachments/assets/dc98dc24-29f9-4e0f-91b6-085481277f9c)

## Data Comparison

Shortest job first has a similar waiting, turnaround, and response times as First come first serve. While Multilevel Feedback Queue has the most efficient CPU utilization. The CPU utilizations with a more advanced system will be lower as to improve overhead, however, a CPU of 80% is the norm for simulated schedulers. 


